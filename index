import heapq
import random
import time
from typing import List, Tuple, Dict, Optional

class DynamicMaze:
    def __init__(self, size: int = 20, obstacle_density: float = 0.3, moving_obstacles: int = 5):
        self.size = size
        self.grid: List[List[int]] = [[0 for _ in range(size)] for _ in range(size)]  # 0: empty, 1: wall, 2: moving obstacle
        self.moving_obstacles: List[Tuple[int, int]] = []
        self._generate_maze()
        self._add_moving_obstacles(moving_obstacles)
        self.start = (0, 0)
        self.goal = (size - 1, size - 1)
        if self.grid[self.start[0]][self.start[1]] == 1 or self.grid[self.goal[0]][self.goal[1]] == 1:
            raise ValueError("Start or goal is blocked during initialization!")

    def _generate_maze(self) -> None:
        # DFS-based maze generation with high complexity
        stack: List[Tuple[int, int]] = [(1, 1)]
        visited: set = set(stack)
        directions = [(0, 2), (2, 0), (0, -2), (-2, 0)]  # Even steps for walls

        while stack:
            x, y = stack[-1]
            random.shuffle(directions)
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 < nx < self.size - 1 and 0 < ny < self.size - 1 and (nx, ny) not in visited:
                    self.grid[x + dx//2][y + dy//2] = 0  # Carve passage
                    stack.append((nx, ny))
                    visited.add((nx, ny))
                    break
            else:
                stack.pop()

        # Add random walls with density
        for i in range(self.size):
            for j in range(self.size):
                if random.random() < self.obstacle_density and (i, j) != self.start and (i, j) != self.goal:
                    self.grid[i][j] = 1

    def _add_moving_obstacles(self, count: int) -> None:
        for _ in range(count):
            while True:
                x, y = random.randint(0, self.size - 1), random.randint(0, self.size - 1)
                if self.grid[x][y] == 0 and (x, y) != self.start and (x, y) != self.goal:
                    self.grid[x][y] = 2
                    self.moving_obstacles.append((x, y))
                    break

    def move_obstacles(self) -> None:
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for i, (x, y) in enumerate(self.moving_obstacles):
            self.grid[x][y] = 0  # Clear current position
            while True:
                dx, dy = random.choice(directions)
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.size and 0 <= ny < self.size and self.grid[nx][ny] == 0:
                    self.grid[nx][ny] = 2
                    self.moving_obstacles[i] = (nx, ny)
                    break

    def is_valid(self, pos: Tuple[int, int]) -> bool:
        x, y = pos
        return 0 <= x < self.size and 0 <= y < self.size and self.grid[x][y] != 1 and self.grid[x][y] != 2

class AStarWithDynamics:
    def __init__(self, maze: DynamicMaze, max_iterations: int = 10000, simulation_steps: int = 5):
        self.maze = maze
        self.max_iterations = max_iterations
        self.simulation_steps = simulation_steps
        self.directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]  # 8-directional for complexity

    def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> int:
        return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan

    def reconstruct_path(self, came_from: Dict[Tuple[int, int], Tuple[int, int]], current: Tuple[int, int]) -> List[Tuple[int, int]]:
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        return path[::-1]

    def find_path(self) -> Optional[List[Tuple[int, int]]]:
        start = self.maze.start
        goal = self.maze.goal
        open_set: List[Tuple[int, Tuple[int, int]]] = []  # Priority queue: (priority, position)
        heapq.heappush(open_set, (0, start))
        came_from: Dict[Tuple[int, int], Tuple[int, int]] = {}
        g_score: Dict[Tuple[int, int], int] = {start: 0}
        f_score: Dict[Tuple[int, int], int] = {start: self.heuristic(start, goal)}
        visited: set = set()
        iterations = 0

        while open_set and iterations < self.max_iterations:
            iterations += 1
            _, current = heapq.heappop(open_set)
            if current == goal:
                return self.reconstruct_path(came_from, current)

            if current in visited:
                continue
            visited.add(current)

            # Simulate dynamic changes every few steps
            if iterations % self.simulation_steps == 0:
                self.maze.move_obstacles()
                # Re-evaluate if current is now invalid (add complexity)
                if not self.maze.is_valid(current):
                    continue

            for dx, dy in self.directions:
                neighbor = (current[0] + dx, current[1] + dy)
                if self.maze.is_valid(neighbor):
                    tentative_g = g_score[current] + (1 if dx == 0 or dy == 0 else 1.414)  # Euclidean cost for diagonals
                    if neighbor not in g_score or tentative_g < g_score[neighbor]:
                        came_from[neighbor] = current
                        g_score[neighbor] = tentative_g
                        f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal) + random.randint(0, 2)  # Add noise for difficulty
                        heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return None  # No path found

def main():
    try:
        maze = DynamicMaze(size=20, obstacle_density=0.25, moving_obstacles=10)
        astar = AStarWithDynamics(maze, max_iterations=50000, simulation_steps=3)
        start_time = time.time()
        path = astar.find_path()
        end_time = time.time()

        if path:
            print(f"Path found in {end_time - start_time:.2f} seconds with {len(path)} steps.")
            print("Path:", path)
        else:
            print("No path found after maximum iterations.")
    except ValueError as ve:
        print(f"Initialization error: {ve}")
    except Exception as e:
        print(f"Unexpected error: {e}")
    finally:
        print("Simulation complete.")

if __name__ == "__main__":
    main()
